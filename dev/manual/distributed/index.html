<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Distributed stochastic programs · StochasticPrograms.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StochasticPrograms.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../quickstart/">Quick start</a></li><li><a class="toctext" href="../data/">Stochastic data</a></li><li><a class="toctext" href="../model/">Stochastic models</a></li><li class="current"><a class="toctext" href>Distributed stochastic programs</a><ul class="internal"></ul></li><li><a class="toctext" href="../structuredsolvers/">Structured solvers</a></li><li><a class="toctext" href="../examples/">Examples</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../../library/public/">Public interface</a></li><li><a class="toctext" href="../../library/solverinterface/">Solver interface</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Distributed stochastic programs</a></li></ul><a class="edit-page" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/master/docs/src/manual/distributed.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Distributed stochastic programs</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Distributed-stochastic-programs-1" href="#Distributed-stochastic-programs-1">Distributed stochastic programs</a></h1><p>Stochastic programs related to industrial applications are often associated with complex models and vast numbers of scenarios, often in the order of <code>1000-1000000</code>. Hence, the extensive form can have billions of variables and constraints, and often does not fit in memory on a single machine. This clarifies the need for solution approaches that work in parallel on distributed data when instansiating and optimizing large-scale stochastic programs.</p><p>If multiple Julia processes are available, locally or in a cluster, StochasticPrograms natively distributes any defined stochastic programs on the available processing nodes. Consider as before:</p><pre><code class="language-julia">using Distributed

addprocs(3)

@everywhere using StochasticPrograms

@scenario Simple = begin
    q₁::Float64
    q₂::Float64
    d₁::Float64
    d₂::Float64
end

@sampler SimpleSampler = begin
    @sample begin
        return SimpleScenario(-24.0 + 2*(2*rand()-1),
                              -28.0 + (2*rand()-1),
                              300.0 + 100*(2*rand()-1),
                              300.0 + 100*(2*rand()-1),
                              probability = rand())
    end
end</code></pre><p><a href="../../library/public/#StochasticPrograms.@scenario"><code>@scenario</code></a> and <a href="../../library/public/#StochasticPrograms.@sampler"><code>@sampler</code></a> automatically ensures that the introduced scenario and sampler types are available on all processes. Define the stochastic model in the usual way:</p><pre><code class="language-julia">simple_model = @stochastic_model begin
    @stage 1 begin
        @variable(model, x₁ &gt;= 40)
        @variable(model, x₂ &gt;= 20)
        @objective(model, Min, 100*x₁ + 150*x₂)
        @constraint(model, x₁ + x₂ &lt;= 120)
    end
    @stage 2 begin
        @decision x₁ x₂
        @uncertain q₁ q₂ d₁ d₂ from SimpleScenario
        @variable(model, 0 &lt;= y₁ &lt;= d₁)
        @variable(model, 0 &lt;= y₂ &lt;= d₂)
        @objective(model, Min, q₁*y₁ + q₂*y₂)
        @constraint(model, 6*y₁ + 10*y₂ &lt;= 60*x₁)
        @constraint(model, 8*y₁ + 5*y₂ &lt;= 80*x₂)
    end
end</code></pre><p>and instantiate an SSA model with 10 sceanarios:</p><pre><code class="language-julia">saa = SAA(simple_model, SimpleSampler(), 10)</code></pre><p>the lightweight model recipes are passed to all worker nodes. The worker nodes then use the recipes and lightweight sampler object to instansiate second stage models in parallel. This is one of the intended outcomes of the design choices made in StochasticPrograms. The separation between data design and model design allows us to minimize data passing in a natural way.</p><p>Many operations in StochasticPrograms are embarassingly parallel which is exploited throughout when a stochastic program is distributed. Notably:</p><ul><li><a href="../../library/public/#StochasticPrograms.evaluate_decision-Tuple{StochasticProgram{2,M,S,SP} where SP&lt;:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S&lt;:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M,AbstractArray{T,1} where T,AbstractScenario}"><code>evaluate_decision</code></a></li><li><a href="../../library/public/#StochasticPrograms.EVPI-Tuple{StochasticProgram{2,M,S,SP} where SP&lt;:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S&lt;:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M}"><code>EVPI</code></a></li><li><a href="../../library/public/#StochasticPrograms.VSS-Tuple{StochasticProgram{2,M,S,SP} where SP&lt;:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S&lt;:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M}"><code>VSS</code></a></li></ul><p>Perform many subproblem independent operations in parallel. The best performance is achieved if the optimization of the recourse problem is performed by an algorithm that can operate in parallel on the distributed stochastic programs. The solver suites <a href="../structuredsolvers/#LShapedSolvers.jl-1">LShapedSolvers.jl</a> and <a href="../structuredsolvers/#ProgressiveHedgingSolvers.jl-1">ProgressiveHedgingSolvers.jl</a> are examples of this. For example, we can optimize the distributed version of the simple stochastic program with a parallelized L-shaped algorithm as follows:</p><pre><code class="language-julia">using LShapedSolvers
using GLPKMathProgInterface

optimize!(sp, solver = LShapedSolver(GLPKSolverLP(), distributed = true))</code></pre><pre><code class="language-julia">Distributed L-Shaped Gap  Time: 0:00:03 (6 iterations)
  Objective:       -855.8333333333339
  Gap:             0.0
  Number of cuts:  7
:Optimal</code></pre><p>A quick note should also be made about the API calls that become less efficient in a distributed setting. This includes all calls that collect data that reside on remote processes. The functions in this category that involve the most data passing is <a href="../../library/public/#StochasticPrograms.scenarios"><code>scenarios</code></a>, which fetches all scenarios in the stochastic program, and <a href="../../library/public/#StochasticPrograms.subproblems"><code>subproblems</code></a>, which fetches all second stage models in the stochastic program. If these collections are required frequently it is recommended to not distribute the stochastic program. This can be ensured by supplying <code>procs = [1]</code> to the constructor call. Individual queries <code>scenario(stochasticprogram, i)</code> and <code>subproblem(stochasticprogram, i)</code> are viable depending on the size of the scenarios/models. If a <code>MathProgBase</code> solver is supplied to a distributed stochastic program it will fetch all scenarios to the master node and attempt to build the extensive form. Long computation times are expected for large-scale models, assuming they fit in memory. If so, it is again recommended to avoid distributing the stochastic program through <code>procs = [1]</code>. The best approach is to use a structured solver that can operate on distributed stochastic programs, such as <a href="../structuredsolvers/#LShapedSolvers.jl-1">LShapedSolvers.jl</a> or <a href="../structuredsolvers/#ProgressiveHedgingSolvers.jl-1">ProgressiveHedgingSolvers.jl</a>.</p><footer><hr/><a class="previous" href="../model/"><span class="direction">Previous</span><span class="title">Stochastic models</span></a><a class="next" href="../structuredsolvers/"><span class="direction">Next</span><span class="title">Structured solvers</span></a></footer></article></body></html>
