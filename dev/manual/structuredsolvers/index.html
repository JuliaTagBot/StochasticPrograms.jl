<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Structured solvers · StochasticPrograms.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StochasticPrograms.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../quickstart/">Quick start</a></li><li><a class="toctext" href="../data/">Stochastic data</a></li><li><a class="toctext" href="../model/">Stochastic models</a></li><li><a class="toctext" href="../distributed/">Distributed stochastic programs</a></li><li class="current"><a class="toctext" href>Structured solvers</a><ul class="internal"><li><a class="toctext" href="#Solver-interface-1">Solver interface</a></li><li><a class="toctext" href="#LShapedSolvers.jl-1">LShapedSolvers.jl</a></li><li><a class="toctext" href="#ProgressiveHedgingSolvers.jl-1">ProgressiveHedgingSolvers.jl</a></li></ul></li><li><a class="toctext" href="../examples/">Examples</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../../library/public/">Public interface</a></li><li><a class="toctext" href="../../library/solverinterface/">Solver interface</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Structured solvers</a></li></ul><a class="edit-page" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/master/docs/src/manual/structuredsolvers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Structured solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Structured-solvers-1" href="#Structured-solvers-1">Structured solvers</a></h1><p>A stochastic program has a structure that can exploited in solver algorithms through decomposition. This can heavily reduce the computation time required to optimize the stochastic program, compared to solving the extensive form directly. Moreover, a distributed stochastic program is by definition decomposed and a structured solver that can operate in parallel will be much more efficient.</p><h2><a class="nav-anchor" id="Solver-interface-1" href="#Solver-interface-1">Solver interface</a></h2><p>The structured solver interface mimics that of <code>MathProgBase</code>, and it needs to be implemented by any structured solver to be compatible with StochasticPrograms. We distinguish between structure-exploiting solvers for solving finite stochastic programs and sampled-bases solvers for approximately solving stochastic models, even though they can be based on the same algorithm.</p><p>Some procedures in StochasticPrograms require a <code>MathProgBase</code> solver. It is common that structured solvers rely internally on some <code>MathProgBase</code> solver. Hence, for convenience, a solver can implement <a href="../../library/solverinterface/#StochasticPrograms.internal_solver-Tuple{AbstractSampledSolver}"><code>internal_solver</code></a> to return any internal <code>MathProgBase</code> solver. A stochastic program that has an loaded structured solver that implements this method can then make use of that solver for those procedures, instead of requiring an external solver to be supplied. Finally, a structured solver can optionally implement <a href="../../library/solverinterface/#StochasticPrograms.solverstr-Tuple{AbstractSampledSolver}"><code>solverstr</code></a> to return an informative description string for printouts.</p><h3><a class="nav-anchor" id="Stochastic-programs-1" href="#Stochastic-programs-1">Stochastic programs</a></h3><p>To interface a new structure-exploiting solver, define a shallow object of type <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredSolver"><code>AbstractStructuredSolver</code></a>. This object is intended to be the interface to end users of the solver and is what should be passed to <a href="../../library/public/#StochasticPrograms.optimize!-Tuple{StochasticProgram{2,M,S,SP} where SP&lt;:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S&lt;:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M}"><code>optimize!</code></a>. Define a new structured solver as a subtype of <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredModel"><code>AbstractStructuredModel</code></a>. Next, implement <a href="../../library/solverinterface/#StochasticPrograms.StructuredModel-Tuple{StochasticProgram,AbstractStructuredSolver}"><code>StructuredModel</code></a>, that takes the stochastic program and the <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredSolver"><code>AbstractStructuredSolver</code></a> object and return an instance of <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredModel"><code>AbstractStructuredModel</code></a> which internal state depends on the given stochastic program. Next, the solver algorithm should be run when calling <a href="../../library/solverinterface/#StochasticPrograms.optimize_structured!-Tuple{AbstractStructuredModel}"><code>optimize_structured!</code></a> on the <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredModel"><code>AbstractStructuredModel</code></a>. After successfuly optimizing the model, the solver must be able to fill in the optimal solution in the first stage and all second stages through <a href="../../library/solverinterface/#StochasticPrograms.fill_solution!-Tuple{StochasticProgram,AbstractStructuredModel}"><code>fill_solution!</code></a>.</p><p>In summary, the solver interface that a new <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredModel"><code>AbstractStructuredModel</code></a> and <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredSolver"><code>AbstractStructuredSolver</code></a> pair should adhere to is given by</p><ul><li><a href="../../library/solverinterface/#StochasticPrograms.StructuredModel-Tuple{StochasticProgram,AbstractStructuredSolver}"><code>StructuredModel</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.optimize_structured!-Tuple{AbstractStructuredModel}"><code>optimize_structured!</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.fill_solution!-Tuple{StochasticProgram,AbstractStructuredModel}"><code>fill_solution!</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.internal_solver-Tuple{AbstractSampledSolver}"><code>internal_solver</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.solverstr-Tuple{AbstractSampledSolver}"><code>solverstr</code></a></li></ul><p>As an example, a simplified version of the implementation of the structured solver interface in <a href="#LShapedSolvers.jl-1">LShapedSolvers.jl</a> is given below:</p><pre><code class="language-julia">abstract AbstractLShapedSolver &lt;: AbstractStructuredModel end

const MPB = MathProgBase

mutable struct LShapedSolver &lt;: AbstractStructuredSolver
    lpsolver::MPB.AbstractMathProgSolver
    subsolver::MPB.AbstractMathProgSolver
    complete_recourse::Bool
    crash::Crash.CrashMethod
    parameters::Dict{Symbol,Any}

    function LShapedSolver(lpsolver::MPB.AbstractMathProgSolver;
                           complete_recourse::Bool = true,
                           regularize::AbstractRegularizer = DontRegularize(),
                           crash::Crash.CrashMethod = Crash.None(),
                           subsolver::MPB.AbstractMathProgSolver = lpsolver, kwargs...)
        return new(lpsolver, subsolver, complete_recourse, regularize, crash, Dict{Symbol,Any}(kwargs))
    end
end

function StructuredModel(stochasticprogram::StochasticProgram, solver::LShapedSolver)
    x₀ = solver.crash(stochasticprogram, solver.lpsolver)
    return LShaped(stochasticprogram, x₀, solver.lpsolver, solver.subsolver, solver.checkfeas; solver.parameters...)
end

function internal_solver(solver::LShapedSolver)
    return solver.lpsolver
end

function optimize_structured!(lshaped::AbstractLShapedSolver)
    return lshaped()
end

function fill_solution!(stochasticprogram::StochasticProgram, lshaped::AbstractLShapedSolver)
    # First stage
    first_stage = StochasticPrograms.get_stage_one(stochasticprogram)
    nrows, ncols = first_stage_dims(stochasticprogram)
    StochasticPrograms.set_decision!(stochasticprogram, decision(lshaped))
    μ = try
        MPB.getreducedcosts(lshaped.mastersolver.lqmodel)[1:ncols]
    catch
        fill(NaN, ncols)
    end
    StochasticPrograms.set_first_stage_redcosts!(stochasticprogram, μ)
    λ = try
        MPB.getconstrduals(lshaped.mastersolver.lqmodel)[1:nrows]
    catch
        fill(NaN, nrows)
    end
    StochasticPrograms.set_first_stage_duals!(stochasticprogram, λ)
    # Second stage
    fill_submodels!(lshaped, scenarioproblems(stochasticprogram))
end

function solverstr(solver::LShapedSolver)
    return &quot;L-shaped solver&quot;
end</code></pre><h3><a class="nav-anchor" id="Stochastic-models-1" href="#Stochastic-models-1">Stochastic models</a></h3><p>To interface a new sampled-based solver, define a shallow object of type <a href="../../library/solverinterface/#StochasticPrograms.AbstractSampledSolver"><code>AbstractSampledSolver</code></a>. This object is intended to be the interface to end users of the solver and is what should be passed to <a href="../../library/public/#StochasticPrograms.optimize-Tuple{StochasticModel,AbstractSampler}"><code>optimize</code></a>.Similar to finite programs, define a new sampled-based solver as a subtype of <a href="../../library/solverinterface/#StochasticPrograms.AbstractSampledModel"><code>AbstractSampledModel</code></a>. Next, implement <a href="../../library/solverinterface/#StochasticPrograms.SampledModel-Tuple{StochasticModel,AbstractSampledSolver}"><code>SampledModel</code></a>, that takes a stochastic model and the <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredSolver"><code>AbstractStructuredSolver</code></a> object and returns an instance of <a href="../../library/solverinterface/#StochasticPrograms.AbstractSampledModel"><code>AbstractSampledModel</code></a>. Next, the solver algorithm should be run when calling <a href="../../library/solverinterface/#StochasticPrograms.optimize_sampled!-Tuple{AbstractSampledModel,AbstractSampler,AbstractFloat}"><code>optimize_sampled!</code></a> on the <a href="../../library/solverinterface/#StochasticPrograms.AbstractSampledModel"><code>AbstractSampledModel</code></a>, some <a href="../../library/public/#StochasticPrograms.AbstractSampler"><code>AbstractSampler</code></a> and a desired confidence level. After successfuly optimizing the model, a <a href="../../library/public/#StochasticPrograms.StochasticSolution"><code>StochasticSolution</code></a> should be retrivable from the <a href="../../library/solverinterface/#StochasticPrograms.AbstractSampledModel"><code>AbstractSampledModel</code></a> using <a href="../../library/solverinterface/#StochasticPrograms.stochastic_solution-Tuple{AbstractSampledModel}"><code>stochastic_solution</code></a></p><p>In summary, the solver interface that a new <a href="../../library/solverinterface/#StochasticPrograms.AbstractSampledModel"><code>AbstractSampledModel</code></a> and <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredSolver"><code>AbstractStructuredSolver</code></a> pair should adhere to is given by</p><ul><li><a href="../../library/solverinterface/#StochasticPrograms.SampledModel-Tuple{StochasticModel,AbstractSampledSolver}"><code>SampledModel</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.optimize_sampled!-Tuple{AbstractSampledModel,AbstractSampler,AbstractFloat}"><code>optimize_sampled!</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.stochastic_solution-Tuple{AbstractSampledModel}"><code>stochastic_solution</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.internal_solver-Tuple{AbstractSampledSolver}"><code>internal_solver</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.solverstr-Tuple{AbstractSampledSolver}"><code>solverstr</code></a></li></ul><p>As an example, consider the implementation of the <a href="../../library/public/#StochasticPrograms.SAASolver"><code>SAASolver</code></a>:</p><pre><code class="language-julia">struct SAASolver{S &lt;: SPSolverType} &lt;: AbstractStructuredSolver
    internal_solver::S

    function SAASolver(solver::SPSolverType)
        if isa(solver, JuMP.UnsetSolver)
            error(&quot;Cannot solve emerging SAA problems without functional solver.&quot;)
        end
        S = typeof(solver)
        return new{S}(solver)
    end
end
function SAASolver(; solver::SPSolverType = JuMP.UnsetSolver())
    return SAASolver(solver)
end

mutable struct SAAModel{M &lt;: StochasticModel, S &lt;: SPSolverType} &lt;: AbstractSampledModel
    stochasticmodel::M
    solver::S
    solution::StochasticSolution
end

function SampledModel(stochasticmodel::StochasticModel, solver::SAASolver)
    return SAAModel(stochasticmodel, solver.internal_solver, EmptySolution())
end

function optimize_sampled!(saamodel::SAAModel, sampler::AbstractSampler, confidence::AbstractFloat; M::Integer = 10, tol::AbstractFloat = 1e-1, Nmax::Integer = 5000)
    sm = saamodel.stochasticmodel
    solver = saamodel.solver
    n = 16
    α = 1-confidence
    while true
        CI = confidence_interval(sm, sampler; solver = solver, confidence = 1-α, N = n, M = M)
        saa = SAA(sm, sampler, n)
        optimize!(saa, solver = solver)
        Q = optimal_value(saa)
        if length(CI)/abs(Q+1e-10) &lt;= tol &amp;&amp; Q ∈ CI
            saamodel.solution = StochasticSolution(optimal_decision(saa), Q, CI)
            return :Optimal
        end
        n = n * 2
        if n &gt; Nmax
            return :LimitReached
        end
    end
end

function stochastic_solution(saamodel::SAAModel)
    return saamodel.solution
end</code></pre><h2><a class="nav-anchor" id="LShapedSolvers.jl-1" href="#LShapedSolvers.jl-1">LShapedSolvers.jl</a></h2><p>LShapedSolvers is a collection of structured optimization algorithms for two-stage (L-shaped) stochastic recourse problems. All algorithm variants are based on the L-shaped method by Van Slyke and Wets. LShapedSolvers interfaces with StochasticPrograms through the structured solver interface. It is available as an unregistered package on Github, ans can be installed as follows:</p><pre><code class="language-julia">pkg&gt; add https://github.com/martinbiel/LShapedSolvers.jl</code></pre><div></div><p>As an example, we solve the simple problem introduced in the <a href="../quickstart/#Quick-start-1">Quick start</a>:</p><pre><code class="language-julia">using LShapedSolvers
using GLPKMathProgInterface

optimize!(sp, solver = LShapedSolver(GLPKSolverLP()))</code></pre><pre><code class="language-julia">L-Shaped Gap  Time: 0:00:01 (6 iterations)
  Objective:       -855.8333333333358
  Gap:             0.0
  Number of cuts:  8
:Optimal</code></pre><p>Note, that an LP capable <code>AbstractMathProgSolver</code> is required to solve emerging subproblems. The following variants of the L-shaped algorithm are implemented:</p><ol><li>L-shaped with multiple cuts (default): <code>regularization = DontRegularize()</code></li><li>L-shaped with regularized decomposition: <code>regularization = RegularizedDecomposition(; kw...)/RD(; kw...)</code></li><li>L-shaped with trust region: <code>regularization = TrustRegion(; kw...)/TR(; kw...)</code></li><li>L-shaped with level sets: <code>regularization = LevelSet(; projectionsolver, kw...)/LV(; projectionsolver, kw...)</code></li></ol><p>Note, that <code>RD</code> and <code>LV</code> both require a QP capable <code>AbstractMathProgSolver</code> for the master/projection problems. If not available, setting the <code>linearize</code> keyword to <code>true</code> is an alternative.</p><p>In addition, there is a distributed variant of each algorithm, created by supplying <code>distributed = true</code> to the factory method. This requires adding processes with <code>addprocs</code> prior to execution. The distributed variants are designed for StochasticPrograms, and are most efficient when run on distributed stochastic programs.</p><p>Each algorithm has a set of parameters that can be tuned prior to execution. For a list of these parameters and their default values, use <code>?</code> in combination with the solver object. For example, <code>?TrustRegion</code> gives the parameter list of the L-shaped algorithm with trust-region regularization. For a list of all solvers and their handle names, use <code>?LShapedSolver</code>.</p><h2><a class="nav-anchor" id="ProgressiveHedgingSolvers.jl-1" href="#ProgressiveHedgingSolvers.jl-1">ProgressiveHedgingSolvers.jl</a></h2><p>ProgressiveHedgingSolvers includes implementations of the progressive-hedging algorithm for two-stage stochastic recourse problems. All algorithm variants are based on the original progressive-hedging algorithm by Rockafellar and Wets. ProgressiveHedgingSolvers interfaces with StochasticPrograms through the structured solver interface. It is available as an unregistered package on Github, ans can be installed as follows:</p><pre><code class="language-julia">pkg&gt; add https://github.com/martinbiel/LShapedSolvers.jl</code></pre><p>As an example, we solve the simple problem introduced in the <a href="../quickstart/#Quick-start-1">Quick start</a>:</p><pre><code class="language-julia">using ProgressiveHedgingSolvers
using Ipopt

optimize!(sp, solver = ProgressiveHedgingSolver(:ph, IpoptSolver(print_level=0)))</code></pre><pre><code class="language-julia">Progressive Hedging Time: 0:00:06 (1315 iterations)
  Objective:  -855.8332803469448
  δ:          9.570267362791345e-7
:Optimal</code></pre><p>Note, that a QP capable <code>AbstractMathProgSolver</code> is required to solve emerging subproblems.</p><p>An adaptive penalty parameter can be used by supplying <code>penalty = :adaptive</code> to the factory method.</p><p>By default, the execution is <code>:sequential</code>. Supplying either <code>execution = :synchronous</code> or <code>execution = :asynchronous</code> to the factory method yields distributed variants of the algorithm. This requires adding processes with <code>addprocs</code> prior to execution. The distributed variants are designed for StochasticPrograms, and is most efficient when run on distributed stochastic programs.</p><p>The algorithm variants has a set of parameters that can be tuned prior to execution. For a list of these parameters and their default values, use <code>?</code> in combination with the solver object. For example, <code>?ProgressiveHedging</code> gives the parameter list of the sequential progressive-hedging algorithm. For a list of all solvers and their handle names, use <code>?ProgressiveHedgingSolver</code>.</p><footer><hr/><a class="previous" href="../distributed/"><span class="direction">Previous</span><span class="title">Distributed stochastic programs</span></a><a class="next" href="../examples/"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
